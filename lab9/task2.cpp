#include <stdio.h> // библиотека ввода-вывода
#include <stdlib.h> // стандартная библиотека встоенных функций, нужна для malloc
#include <time.h> // библиотека для генерации случайных значений


// эти константы добавлены исключительно для улучшения читаемости кода
#define TRUE 1 // константа, обозначающая булеву истину
#define FALSE 0 // константа, обозначающая булеву ложь


struct Node { // структура элемента списка
    int value; // значение элементы списка
    struct Node *next; // указатель на следующий элемент в списке
    struct Node *prev; // указатель на предыдущий элемент в списке
};


struct Node* traverse_list_till_end(struct Node*); // функция получения последнего элемента списка
struct Node* traverse_list_by_offset(struct Node*, int); // функция получения n-го элемента списка
int find_min_offset(struct Node*); // функция нахождения позиции минимального элемента в списке
int find_max_offset(struct Node*); // функция нахождения позиции максимального элемента в списке
struct Node* create_random_list(void); // функция создания случайного списка
struct Node* create_list(void); // функция создания списка
void view_list(struct Node*); // функция вывода списка в консоль
void update_list(struct Node*); // функция добавления элемента в список
struct Node* special_task(void); // функция выполнения индивидуального задания варианта 10
void free_memory(struct Node*); // функция освобождения выделенной под список памяти


int main()
{
    char list_exists = FALSE; // создание и инициализация флага присутствия списка
    int choice; // переменная для выбора функции программы для выполнения
    struct Node *list; // указатель на первый элемент списка

    srand(time(NULL)); // установить в качестве базы для генерации случайного числа текущее время

    do {
        /*
        Вывод меню для выбора функции на выполнение
        */
        puts("Выберите команду для выполнения:");
        puts("1 - Создать пустой список");
        puts("2 - Просмотреть список");
        puts("3 - Добавить элемент в список");
        puts("4 - Создать два случайных списка и между максимальным и минимальным елементами первого вставить второй");

        scanf("%d", &choice); // ввод пользователем желаемой номера функции

        switch (choice) // выполнение команд исходя из пользовательского ввода
        {
            case 1:
                list = create_list(); // создать список
                if (list != NULL) // если список был создан
                {
                    list_exists = TRUE; // обновление флага присутствия списка
                    puts("Список создан"); // уведомить пользователья о создании списка
                }
                else
                {
                    list_exists = FALSE; // иначе установить флаг присутсвия списка в false
                    puts("В процессе создания списка возникла ошибка"); // уведомить пользователя
                }
                break;
            case 2:
                if (list_exists) // если список создан
                {
                    view_list(list); // вызов функции вывода списка в консоль
                }
                else
                {
                    puts("Список не был создан. Нечего показывать"); // иначе сообщить пользователю, что нечего показывать
                }
                break;
            case 3:
                if (list_exists) // если список создан
                {
                    update_list(list); // добавить элемент в список
                }
                else
                {
                    puts("Список не был создан. Некуда добавлять"); // иначе сообщить пользователю, что некуда добавлять
                }
                break;
            case 4:
                list = special_task(); // создать список из двух случайных списков
                if (list != NULL) // если список создан
                {
                    list_exists = TRUE; // обновление флага присутствия списка
                    puts("Список из случайных элементов создан"); // уведомить пользователья о создании списка
                }
                else
                {
                    list_exists = FALSE; // иначе установить флаг существования списка false
                    puts("В процессе создания списка возникла ошибка"); // уведомить пользователя
                }
                break;
            default:
                free_memory(list); // вызов функции освобождения памяти
                return 0; // выйти из программы со статус-кодом 0 (успешное завершение)
        }
    /*
    данный цикл выполняется до тех пор, пока пользователем на вопрос о выборе
    команды на выполнение вводится число, поддерживаемое оператором switch, описанным
    выше. при несовпадении значений выполяется блок default, который освобождает
    выделенную под список память и завершает программу со статусом 0 (выполнена успешно)
    */
    } while(TRUE);
}


struct Node* traverse_list_till_end(struct Node *list_beginning)
{
    struct Node *list_ending; // указатель на конец списка
    list_ending = list_beginning; // инициализация указателя на конец списка адресом первого элемента списка

    while (list_ending->next != NULL) // пока следующий элемент существует
    {
        list_ending = list_ending->next; // передвинуть указатель на следующий элемент
    }

    return list_ending; // вернуть указатель на последний элемент списка
}


struct Node* traverse_list_by_offset(struct Node *list_beginning, int offset)
{
    int counter = 0; // инициализация счетчика
    struct Node *current_element; // указатель на текущий элемент списка
    current_element = list_beginning; // инициализация указателя на текущий элемент списка адресом первого элемента списка

    while (counter < offset) // пока счетчик меньше отступа от начала списка
    {
        current_element = current_element->next; // передвинуть указатель на следующий элемент списка
        counter++; // увеличить счетчик на единицу
    }

    return current_element; // вернуть указатель на элемент списка с отступом offset от начала списка
}


int find_min_offset(struct Node *list)
{
    int offset, counter = 0, min_value; // отступ от начала списка, отступ текущего элемента списка, минимальное значение
    struct Node *current_node; // указатель на текущий элемент списка

    current_node = list; // инициализация указателя на текущий элемент списка адресом первого элемента списка
    min_value = current_node->value; // инициализация минимального значения значением текущего элемента списка

    while (current_node != NULL) // пока текущий элемент списка существует
    {
        if (current_node->value < min_value) // если значение текущего элемента списка меньше минимального
        {
            min_value = current_node->value; // сделать значение текущего элемента минимальным
            offset = counter; // сохранить отступ минимального элемента от начала списка
        }
        counter++; // увеличить отступ текущего элемента списка на единицу
        current_node = current_node->next; // передвинуть указатель на следующий элемент списка
    }

    return offset; // вернуть отступ минимального элемента списка
}


int find_max_offset(struct Node *list)
{
    int offset, counter = 0, max_value; // отступ от начала списка, отступ текущего элемента списка, максимальное значение
    struct Node *current_node; // указатель на текущий элемент списка

    current_node = list; // инициализация указателя на текущий элемент списка адресом первого элемента списка
    max_value = current_node->value; // инициализация максимального значения значением текущего элемента списка

    while (current_node != NULL) // пока текущий элемент списка существует
    {
        if (current_node->value > max_value) // если значение текущего элемента больше максимального
        {
            max_value = current_node->value; // сделать значение текущего элемента максимальным
            offset = counter; // сохранить отсутп максимального элемента от начала списка
        }
        counter++; // увеличить отступ текущего элемента на единицу
        current_node = current_node->next; // передвинуть указатель на следующий элемент списка
    }

    return offset; // вернуть отступ максимального элемента списка
}


struct Node* create_random_list()
{
    int length; // длина случайного списка
    struct Node *random_list, *current_element, *tmp; // указатели на начало случайного списка, текущий элемент, новый элемент

    do {
        puts("Введите длину списка случайных элементов:");
        scanf("%d", &length); // ввод пользователем длины случайного списка
    }
    while (length <= 0); // пока не введена положительная длина

    current_element = (struct Node*) malloc(sizeof(struct Node)); // выделение памяти под элемент случайного списка
    if (current_element != NULL) // если память выделить не удалось
    {
        puts("Не удалось выделить память под элемент случайного списка."); // проинформировать пользователя
        return NULL; // вернуть из функции NULL
    }
    current_element->value = rand()/10000000; // генерация и инициализация случайного значения первого элемента
    current_element->next = NULL; // инициализация указателя на следующий элемент значением NULL, так как его пока нет
    current_element->prev = NULL; // инициализация указателя на предыдущий элемент значением NULL, так как это первый элемент
    random_list = current_element; // сохранение указателя на первый элемент списка в переменную

    while (length-1 > 0) // пока не все элементы созданы
    {
        tmp = (struct Node*) malloc(sizeof(struct Node)); // выделить память под новый элемент списка
        if (tmp != NULL) // если память выделить не удалось
        {
            puts("Не удалось выделить память под элемент случайного списка."); // проинформировать пользователя
            return NULL; // вернуть из функции NULL
        }
        tmp->value = rand()/10000000; // генерация и инициализация случайного значения первого элемента
        tmp->next = NULL; // инициализация указателя на следующий элемент значением NULL, так как его пока нет
        current_element->next = tmp; // установка указателя на следующий элемент текущего элемента
        tmp->prev = current_element; // установка указателя на предыдущий элемент нового элемента
        current_element = tmp; // перемещение указателя текущего элемента на новый элемент
        length--; // уменьшение количества осавшихся еще недобавленными элементов списка на единицу
    }

    return random_list; // вернуть указатель на первый элемент случайного списка
}


struct Node* create_list()
{
    struct Node* new_list; // указатель на первый элемент нового списка
    int initial_value; // значение первого элемента нового списка

    puts("Проинициализируйте первый элемент списка:");
    scanf("%d", &initial_value); // ввод пользователем значения первого элемента нового списка

    new_list = (struct Node*) malloc(sizeof(struct Node)); // выделение памяти под первый элемент нового списка
    if (new_list != NULL) // если память выделить не удалось
    {
        puts("Не удалось выделить память под элемент списка."); // уведомить пользователя
        return NULL; // вернуть из функции NULL
    }
    new_list->value = initial_value; // инициализация значения первого элемента списка
    new_list->next = NULL; // инициализация указателя на следующий элемент значением NULL, так как его пока нет
    new_list->prev = NULL; // инициализация указателя на предыдущий элемент значением NULL, так как это первый элемент

    puts("Создан новый список c первым элементом со значением по умолчанию."); // уведомить пользователя

    return new_list; // вернуть указатель на первый элемент созданного списка
}


void update_list(struct Node *list)
{
    struct Node *new_list_node, *last_list_node; // указатели на новый и последний элементы списка
    int new_value; // значение нового элемента списка

    new_list_node = (struct Node*) malloc(sizeof(struct Node)); // выделение памяти под новый элемент списка
    if (new_list_node == NULL) // если память выделить не удалось
    {
        puts("Недостаточно памяти для создания нового элемента в списке."); // уведомить пользователя
        return; // прекратить выполнение функции
    }

    puts("Введите значение нового элемента списка:");
    scanf("%d", &new_value); // ввод пользователем значения нового элемента списка
    new_list_node->value = new_value; // инициализация значения нового элемента списка
    new_list_node->next = NULL; // установление указателя на следующий элемент в значение NULL

    last_list_node = traverse_list_till_end(list); // получение указателя на последний элемент списка
    last_list_node->next = new_list_node; // установление указателя на следующий элемент списка последнего элемента в
    // значение адреса нового элемента списка
    new_list_node->prev = last_list_node; // установление указателя на предыдущий элемент списка нового элемента в
    // значение адреса последнего элемента списка
}


void view_list(struct Node *list)
{
    struct Node* current_node; // указатель на элемент списка
    current_node = list; // инициализация указателя адресом первого значения списка

    while (current_node != NULL) // пока элемент существует
    {
        printf("| %d ", current_node->value); // вывести его с отделяющей чертой без символа новой строки
        current_node = current_node->next; // перевести указатель на следующий элемент
    }
    printf("|\n"); // напечатать закрывающую список черту и символ конца строки
}


struct Node* special_task()
{
    /*
    указатели на первый элемент первого случайного списка, первый элемент второго
    случайного списка, на начало и конец области вставки второго списка в первый
    */
    struct Node *first_random_list, *second_random_list, *start, *finish;
    // отступы минимального и максимального элементов списка, вспомогательная переменная для обмена и счетчик
    int min_offset, max_offset, tmp, counter = 0;

    first_random_list = create_random_list(); // создание и инициализация первого случайного списка
    second_random_list = create_random_list(); // создание и инициализация второго случайного списка

    puts("Первый случайный список:");
    view_list(first_random_list); // вывод на экран первого случайного списка
    puts("Второй случайный список:");
    view_list(second_random_list); // вывод на экран второго случайного списка

    min_offset = find_min_offset(first_random_list); // поиск и инициализация отступа минимального элемента
    max_offset = find_max_offset(first_random_list); // поиск и инициализация отступа максимального элемента

    if (min_offset > max_offset) // если отступ минимального элемента больше отступа максимального
    {
        // меняем значения отступов местами
        tmp = min_offset; // сохранить минимальный отступ во вспомогательную переменную
        min_offset = max_offset; // присвоение минимальному отступу максимального отступа
        max_offset = tmp; // присвоение максимальному отступу значения вспомогательной переменной
    }

    start = traverse_list_by_offset(first_random_list, min_offset); // поиск и инициализация указателя на минимальный элемент
    finish = traverse_list_by_offset(first_random_list, max_offset); // поиск и инициализация указателя на максимальный элемент
    start->next = second_random_list; // следующий элемент после минимального - первый элемент второго списка
    second_random_list->prev = start; // предыдущий элемент первого элемента второго списка - минимальный элемент первого
    second_random_list = traverse_list_till_end(second_random_list); // поиск последнего элемента второго списка
    second_random_list->next = finish; // следующий элемент после последнего элемента второго списка - максимальный первого
    finish->prev = second_random_list; // предыдущий элемент максимального элемента первого списка - последний второго

    puts("Полученный в результате совмещения список:");
    view_list(first_random_list); // вывести полученный в реузльтате список

    return first_random_list; // вернуть полученный в результате список
}


void free_memory(struct Node *node)
{
    if (node != NULL) // если элемент списка существует
    {
        free_memory(node->next); // рекурсивно вызывать функцию освобождения памяти для следующего элемента
        free(node); // освободить память, выделенную под элемент списка
    }
}
